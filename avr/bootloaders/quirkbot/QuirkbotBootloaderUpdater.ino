/* http://srecord.sourceforge.net/ */
const PROGMEM uint8_t bootloader_data[] =
{
0x55, 0xC0, 0x00, 0x00, 0x93, 0xC0, 0x00, 0x00, 0x91, 0xC0, 0x00, 0x00,
0x8F, 0xC0, 0x00, 0x00, 0x8D, 0xC0, 0x00, 0x00, 0x8B, 0xC0, 0x00, 0x00,
0x89, 0xC0, 0x00, 0x00, 0x87, 0xC0, 0x00, 0x00, 0x85, 0xC0, 0x00, 0x00,
0x83, 0xC0, 0x00, 0x00, 0x0E, 0xC5, 0x00, 0x00, 0x7F, 0xC0, 0x00, 0x00,
0x7D, 0xC0, 0x00, 0x00, 0x7B, 0xC0, 0x00, 0x00, 0x79, 0xC0, 0x00, 0x00,
0x77, 0xC0, 0x00, 0x00, 0x75, 0xC0, 0x00, 0x00, 0x73, 0xC0, 0x00, 0x00,
0x71, 0xC0, 0x00, 0x00, 0x6F, 0xC0, 0x00, 0x00, 0xA9, 0xC2, 0x00, 0x00,
0x6B, 0xC0, 0x00, 0x00, 0x69, 0xC0, 0x00, 0x00, 0x67, 0xC0, 0x00, 0x00,
0x65, 0xC0, 0x00, 0x00, 0x63, 0xC0, 0x00, 0x00, 0x61, 0xC0, 0x00, 0x00,
0x5F, 0xC0, 0x00, 0x00, 0x5D, 0xC0, 0x00, 0x00, 0x5B, 0xC0, 0x00, 0x00,
0x59, 0xC0, 0x00, 0x00, 0x57, 0xC0, 0x00, 0x00, 0x55, 0xC0, 0x00, 0x00,
0x53, 0xC0, 0x00, 0x00, 0x51, 0xC0, 0x00, 0x00, 0x4F, 0xC0, 0x00, 0x00,
0x4D, 0xC0, 0x00, 0x00, 0x4B, 0xC0, 0x00, 0x00, 0x49, 0xC0, 0x00, 0x00,
0x47, 0xC0, 0x00, 0x00, 0x45, 0xC0, 0x00, 0x00, 0x43, 0xC0, 0x00, 0x00,
0x41, 0xC0, 0x00, 0x00, 0x11, 0x24, 0x1F, 0xBE, 0xCF, 0xEF, 0xDA, 0xE0,
0xDE, 0xBF, 0xCD, 0xBF, 0x84, 0xB7, 0x14, 0xBE, 0x81, 0xFD, 0x21, 0xC0,
0x80, 0xFD, 0x07, 0xC0, 0x80, 0x91, 0x85, 0x02, 0x90, 0x91, 0x86, 0x02,
0x87, 0x37, 0x97, 0x47, 0xC1, 0xF4, 0x90, 0xE0, 0x80, 0xE0, 0xFC, 0x01,
0x25, 0x91, 0x34, 0x91, 0x2F, 0x3F, 0x3F, 0x4F, 0x81, 0xF0, 0x28, 0xE1,
0x3F, 0xE0, 0x0F, 0xB6, 0xF8, 0x94, 0xA8, 0x95, 0x20, 0x93, 0x60, 0x00,
0x0F, 0xBE, 0x30, 0x93, 0x60, 0x00, 0x10, 0x92, 0x86, 0x02, 0x10, 0x92,
0x85, 0x02, 0xFC, 0x01, 0x09, 0x95, 0x11, 0xE0, 0xA0, 0xE0, 0xB1, 0xE0,
0xEE, 0xEE, 0xFE, 0xE7, 0x02, 0xC0, 0x05, 0x90, 0x0D, 0x92, 0xA8, 0x3E,
0xB1, 0x07, 0xD9, 0xF7, 0x22, 0xE0, 0xA8, 0xEE, 0xB1, 0xE0, 0x01, 0xC0,
0x1D, 0x92, 0xA5, 0x38, 0xB2, 0x07, 0xE1, 0xF7, 0x84, 0xD0, 0xDF, 0xC6,
0x69, 0xCF, 0x84, 0xE0, 0x80, 0x93, 0xE9, 0x00, 0x80, 0x91, 0xE8, 0x00,
0x85, 0xFF, 0x03, 0xC0, 0x80, 0x91, 0xF1, 0x00, 0x08, 0x95, 0x80, 0x91,
0xE8, 0x00, 0x8B, 0x77, 0x80, 0x93, 0xE8, 0x00, 0x80, 0x91, 0xE8, 0x00,
0x82, 0xFD, 0xF0, 0xCF, 0x8E, 0xB3, 0x81, 0x11, 0xF9, 0xCF, 0x80, 0xE0,
0x08, 0x95, 0x80, 0x91, 0xE8, 0x00, 0x80, 0xFF, 0x02, 0xC0, 0x80, 0xE0,
0x08, 0x95, 0x8E, 0xB3, 0x81, 0x11, 0xF7, 0xCF, 0x81, 0xE0, 0x08, 0x95,
0xCF, 0x93, 0xC8, 0x2F, 0x83, 0xE0, 0x80, 0x93, 0xE9, 0x00, 0x80, 0x91,
0xE8, 0x00, 0x85, 0xFF, 0x04, 0xC0, 0xC0, 0x93, 0xF1, 0x00, 0xCF, 0x91,
0x08, 0x95, 0x80, 0x91, 0xE8, 0x00, 0x8E, 0x77, 0x80, 0x93, 0xE8, 0x00,
0xE2, 0xDF, 0x88, 0x23, 0xA1, 0xF3, 0xF5, 0xCF, 0x90, 0x91, 0x78, 0x02,
0xE9, 0x2F, 0xF0, 0xE0, 0xE8, 0x50, 0xFE, 0x4F, 0x80, 0x83, 0x9F, 0x5F,
0x90, 0x93, 0x78, 0x02, 0x90, 0x38, 0x09, 0xF0, 0x3B, 0xC0, 0x80, 0x91,
0x79, 0x02, 0x90, 0x91, 0x7A, 0x02, 0x81, 0x15, 0x20, 0xE7, 0x92, 0x07,
0x58, 0xF5, 0x23, 0xE0, 0xFC, 0x01, 0x20, 0x93, 0x57, 0x00, 0xE8, 0x95,
0x07, 0xB6, 0x00, 0xFC, 0xFD, 0xCF, 0xA8, 0xEF, 0xB1, 0xE0, 0x30, 0xE0,
0x20, 0xE0, 0x61, 0xE0, 0xFC, 0x01, 0xE2, 0x0F, 0xF3, 0x1F, 0x11, 0x96,
0x5C, 0x91, 0x11, 0x97, 0x4C, 0x91, 0x0A, 0x01, 0x60, 0x93, 0x57, 0x00,
0xE8, 0x95, 0x11, 0x24, 0x2E, 0x5F, 0x3F, 0x4F, 0x12, 0x96, 0x20, 0x38,
0x31, 0x05, 0x71, 0xF7, 0x25, 0xE0, 0xFC, 0x01, 0x20, 0x93, 0x57, 0x00,
0xE8, 0x95, 0x07, 0xB6, 0x00, 0xFC, 0xFD, 0xCF, 0x21, 0xE1, 0x20, 0x93,
0x57, 0x00, 0xE8, 0x95, 0x80, 0x58, 0x9F, 0x4F, 0x90, 0x93, 0x7A, 0x02,
0x80, 0x93, 0x79, 0x02, 0x10, 0x92, 0x78, 0x02, 0x08, 0x95, 0x00, 0xD0,
0x00, 0xD0, 0xCD, 0xB7, 0xDE, 0xB7, 0x84, 0xB7, 0x87, 0x7F, 0x84, 0xBF,
0x0F, 0xB6, 0xF8, 0x94, 0xA8, 0x95, 0x80, 0x91, 0x60, 0x00, 0x88, 0x61,
0x80, 0x93, 0x60, 0x00, 0x10, 0x92, 0x60, 0x00, 0x0F, 0xBE, 0x80, 0xE8,
0x90, 0xE0, 0x0F, 0xB6, 0xF8, 0x94, 0x80, 0x93, 0x61, 0x00, 0x90, 0x93,
0x61, 0x00, 0x0F, 0xBE, 0x11, 0xE0, 0x15, 0xBF, 0x82, 0xE0, 0x85, 0xBF,
0xCD, 0xD3, 0x20, 0x9A, 0x28, 0x9A, 0x55, 0x9A, 0x5D, 0x9A, 0x10, 0x93,
0x6F, 0x00, 0x83, 0xE0, 0x80, 0x93, 0x81, 0x00, 0x28, 0x98, 0x5D, 0x9A,
0x81, 0xE5, 0x80, 0x93, 0xE8, 0x01, 0x82, 0xE4, 0x80, 0x93, 0xE9, 0x01,
0x80, 0xE3, 0x80, 0x93, 0xEA, 0x01, 0x81, 0xE3, 0x80, 0x93, 0xEB, 0x01,
0x04, 0xE0, 0x10, 0xE0, 0xC8, 0x01, 0x19, 0xD6, 0xF8, 0x01, 0xE8, 0x51,
0xFE, 0x4F, 0x80, 0x83, 0x0F, 0x5F, 0x1F, 0x4F, 0x00, 0x31, 0x11, 0x05,
0xA9, 0xF7, 0x78, 0x94, 0x01, 0xE0, 0x70, 0xE2, 0xD7, 0x2E, 0xE4, 0xE0,
0xCE, 0x2E, 0xF3, 0xE0, 0xBF, 0x2E, 0xA1, 0xE1, 0xAA, 0x2E, 0xB8, 0xEF,
0xEB, 0x2E, 0xB1, 0xE0, 0xFB, 0x2E, 0x80, 0x91, 0x00, 0x01, 0x81, 0x11,
0x1C, 0xC0, 0x8F, 0xEC, 0x97, 0xE0, 0x01, 0x97, 0xF1, 0xF7, 0x00, 0xC0,
0x00, 0x00, 0x80, 0x91, 0xE0, 0x00, 0x81, 0x60, 0x80, 0x93, 0xE0, 0x00,
0x87, 0xE7, 0x97, 0xE7, 0x90, 0x93, 0x86, 0x02, 0x80, 0x93, 0x85, 0x02,
0x88, 0xE1, 0x9C, 0xE0, 0x0F, 0xB6, 0xF8, 0x94, 0xA8, 0x95, 0x80, 0x93,
0x60, 0x00, 0x0F, 0xBE, 0x90, 0x93, 0x60, 0x00, 0xFF, 0xCF, 0xBE, 0x01,
0x6F, 0x5F, 0x7F, 0x4F, 0x88, 0xE0, 0x91, 0xE0, 0xB8, 0xD5, 0x81, 0x11,
0x11, 0xC0, 0xC0, 0x92, 0xE9, 0x00, 0x80, 0x91, 0xE8, 0x00, 0x82, 0xFF,
0xDA, 0xC0, 0x03, 0xB9, 0xD9, 0xB8, 0xFB, 0xDE, 0x18, 0x2F, 0x85, 0x34,
0x09, 0xF0, 0x3E, 0xC0, 0x10, 0x92, 0x00, 0x01, 0x8D, 0xE0, 0x49, 0xC0,
0x03, 0xB9, 0xD9, 0xB8, 0x8A, 0x81, 0x90, 0xE0, 0x9C, 0x01, 0x20, 0x58,
0x31, 0x09, 0x35, 0x95, 0x27, 0x95, 0x35, 0x95, 0x27, 0x95, 0x2C, 0x30,
0x39, 0xF4, 0x10, 0x92, 0x78, 0x02, 0x10, 0x92, 0x7A, 0x02, 0x10, 0x92,
0x79, 0x02, 0xDB, 0xCF, 0x2D, 0x30, 0x91, 0xF4, 0x1B, 0x81, 0x9C, 0x80,
0x56, 0xE0, 0x88, 0x0F, 0x99, 0x1F, 0x5A, 0x95, 0xE1, 0xF7, 0x91, 0x2F,
0x96, 0x95, 0x89, 0x2B, 0x0B, 0xDF, 0x20, 0xE8, 0x12, 0x9F, 0xC0, 0x01,
0x11, 0x24, 0x89, 0x29, 0x05, 0xDF, 0xC7, 0xCF, 0x2E, 0x30, 0x19, 0xF4,
0x10, 0x92, 0x00, 0x01, 0xC2, 0xCF, 0x2A, 0x30, 0x09, 0xF0, 0xBF, 0xCF,
0xBE, 0x01, 0x6F, 0x5F, 0x7F, 0x4F, 0x88, 0xE0, 0x91, 0xE0, 0x2B, 0xD5,
0x88, 0xE0, 0x91, 0xE0, 0x45, 0xD5, 0xB5, 0xCF, 0x84, 0x35, 0x11, 0xF4,
0xB6, 0xDE, 0xC0, 0xCF, 0x80, 0x35, 0x09, 0xF4, 0xBD, 0xCF, 0x8C, 0x34,
0x09, 0xF4, 0xBA, 0xCF, 0x84, 0x37, 0x29, 0xF4, 0x84, 0xE4, 0xCE, 0xDE,
0x80, 0xE0, 0xCC, 0xDE, 0x67, 0xC0, 0x89, 0xE5, 0x11, 0x36, 0xD9, 0xF3,
0x11, 0x34, 0x91, 0xF4, 0xA2, 0xDE, 0x18, 0x2F, 0xA0, 0xDE, 0x21, 0x2F,
0x30, 0xE0, 0x32, 0x2F, 0x22, 0x27, 0x33, 0x0F, 0x90, 0xE0, 0x88, 0x0F,
0x99, 0x1F, 0x28, 0x2B, 0x39, 0x2B, 0x30, 0x93, 0x7A, 0x02, 0x20, 0x93,
0x79, 0x02, 0x9C, 0xCF, 0x83, 0xE5, 0x10, 0x37, 0x21, 0xF3, 0x13, 0x35,
0x71, 0xF4, 0x81, 0xE5, 0xAD, 0xDE, 0x85, 0xE5, 0xAB, 0xDE, 0x89, 0xE4,
0xA9, 0xDE, 0x82, 0xE5, 0xA7, 0xDE, 0x8B, 0xE4, 0xA5, 0xDE, 0x82, 0xE4,
0xA3, 0xDE, 0x8F, 0xE4, 0xD4, 0xCF, 0x16, 0x35, 0x21, 0xF4, 0x81, 0xE3,
0x9D, 0xDE, 0x80, 0xE3, 0xCE, 0xCF, 0x13, 0x37, 0x31, 0xF4, 0x87, 0xE8,
0x97, 0xDE, 0x85, 0xE9, 0x95, 0xDE, 0x8E, 0xE1, 0xC6, 0xCF, 0x12, 0x36,
0x31, 0xF4, 0x89, 0xE5, 0x8F, 0xDE, 0x80, 0xE0, 0x8D, 0xDE, 0x80, 0xE8,
0xBE, 0xCF, 0x12, 0x34, 0x19, 0xF0, 0x17, 0x36, 0x09, 0xF0, 0x44, 0xC0,
0x62, 0xDE, 0x61, 0xDE, 0x60, 0xDE, 0x12, 0x34, 0x49, 0xF4, 0x10, 0x92,
0x78, 0x02, 0x10, 0xE0, 0x5A, 0xDE, 0x92, 0xDE, 0x1F, 0x5F, 0x10, 0x38,
0xD9, 0xF7, 0x60, 0xCF, 0xA0, 0x92, 0x57, 0x00, 0xE8, 0x95, 0x91, 0x2C,
0x81, 0x2C, 0xE0, 0x91, 0x79, 0x02, 0xF0, 0x91, 0x7A, 0x02, 0xE8, 0x0D,
0xF9, 0x1D, 0x84, 0x91, 0x6B, 0xDE, 0x8F, 0xEF, 0x88, 0x1A, 0x98, 0x0A,
0x90, 0xE8, 0x89, 0x16, 0x91, 0x04, 0x89, 0xF7, 0xB0, 0x92, 0xE9, 0x00,
0x80, 0x91, 0xE8, 0x00, 0x8E, 0x77, 0x80, 0x93, 0xE8, 0x00, 0x80, 0x91,
0xE8, 0x00, 0x85, 0xFD, 0x08, 0xC0, 0x4D, 0xDE, 0x81, 0x11, 0x0F, 0xC0,
0x80, 0x91, 0xE8, 0x00, 0x8E, 0x77, 0x80, 0x93, 0xE8, 0x00, 0x45, 0xDE,
0x81, 0x11, 0x07, 0xC0, 0xC0, 0x92, 0xE9, 0x00, 0x80, 0x91, 0xE8, 0x00,
0x8B, 0x77, 0x80, 0x93, 0xE8, 0x00, 0x88, 0xE0, 0x91, 0xE0, 0xC4, 0xD4,
0x5D, 0xD4, 0xF3, 0xCE, 0x15, 0x35, 0x61, 0xF4, 0x88, 0xEE, 0x88, 0x2E,
0x81, 0xE0, 0x98, 0x2E, 0xF4, 0x01, 0x81, 0x91, 0x4F, 0x01, 0x38, 0xDE,
0xE8, 0x14, 0xF9, 0x04, 0xC9, 0xF7, 0xD0, 0xCF, 0x1B, 0x31, 0x71, 0xF2,
0x8F, 0xE3, 0x63, 0xCF, 0x42, 0xE0, 0x61, 0xEC, 0x82, 0xE0, 0xA2, 0xD1,
0x42, 0xE1, 0x61, 0xE8, 0x83, 0xE0, 0x9E, 0xD1, 0x42, 0xE1, 0x60, 0xE8,
0x84, 0xE0, 0x9A, 0xD1, 0x88, 0xE0, 0x91, 0xE0, 0x55, 0xC4, 0x80, 0x91,
0x7D, 0x02, 0x98, 0x2F, 0x9F, 0x77, 0x91, 0x32, 0x91, 0xF5, 0x90, 0x91,
0x7E, 0x02, 0x91, 0x32, 0xA1, 0xF0, 0x92, 0x32, 0x21, 0xF1, 0x90, 0x32,
0x51, 0xF5, 0x81, 0x32, 0x41, 0xF5, 0x80, 0x91, 0xE8, 0x00, 0x87, 0x7F,
0x80, 0x93, 0xE8, 0x00, 0x67, 0xE0, 0x70, 0xE0, 0x81, 0xE0, 0x91, 0xE0,
0x45, 0xD1, 0x80, 0x91, 0xE8, 0x00, 0x8E, 0x77, 0x0F, 0xC0, 0x81, 0x3A,
0xC1, 0xF4, 0x80, 0x91, 0xE8, 0x00, 0x87, 0x7F, 0x80, 0x93, 0xE8, 0x00,
0x67, 0xE0, 0x70, 0xE0, 0x81, 0xE0, 0x91, 0xE0, 0xD9, 0xD0, 0x80, 0x91,
0xE8, 0x00, 0x8B, 0x77, 0x80, 0x93, 0xE8, 0x00, 0x08, 0x95, 0x81, 0x32,
0x31, 0xF4, 0x80, 0x91, 0xE8, 0x00, 0x87, 0x7F, 0x80, 0x93, 0xE8, 0x00,
0xAF, 0xC1, 0x08, 0x95, 0x8F, 0x93, 0x81, 0xE0, 0x83, 0xB9, 0x80, 0xE2,
0x89, 0xB9, 0x8F, 0x91, 0x18, 0x95, 0x91, 0x30, 0x89, 0xF0, 0x92, 0x30,
0xA1, 0xF0, 0x93, 0x30, 0xE1, 0xF4, 0x88, 0x23, 0xA9, 0xF0, 0x81, 0x50,
0x82, 0x30, 0xB8, 0xF4, 0x82, 0xE1, 0x90, 0xE0, 0x24, 0xE1, 0x31, 0xE0,
0xFA, 0x01, 0x31, 0x83, 0x20, 0x83, 0x08, 0x95, 0x82, 0xE1, 0x90, 0xE0,
0x26, 0xED, 0x31, 0xE0, 0xF7, 0xCF, 0x8A, 0xEA, 0x90, 0xE0, 0x2C, 0xE2,
0x31, 0xE0, 0xF2, 0xCF, 0x84, 0xE0, 0x90, 0xE0, 0x28, 0xE2, 0x31, 0xE0,
0xED, 0xCF, 0x90, 0xE0, 0x80, 0xE0, 0x30, 0xE0, 0x20, 0xE0, 0xE8, 0xCF,
0xAF, 0x92, 0xBF, 0x92, 0xCF, 0x92, 0xDF, 0x92, 0xFF, 0x92, 0x0F, 0x93,
0x1F, 0x93, 0xCF, 0x93, 0xDF, 0x93, 0x6C, 0x01, 0xEB, 0x01, 0x8A, 0x01,
0x90, 0xD1, 0xF8, 0x2E, 0x81, 0x11, 0x24, 0xC0, 0x01, 0x15, 0x11, 0x05,
0x39, 0xF0, 0xF8, 0x01, 0x80, 0x81, 0x91, 0x81, 0xC8, 0x1B, 0xD9, 0x0B,
0xC8, 0x0E, 0xD9, 0x1E, 0xB1, 0x2C, 0xA1, 0x2C, 0x20, 0x97, 0xB1, 0xF0,
0x80, 0x91, 0xE8, 0x00, 0x85, 0xFD, 0x22, 0xC0, 0x80, 0x91, 0xE8, 0x00,
0x8E, 0x77, 0x80, 0x93, 0xE8, 0x00, 0xAC, 0xD3, 0x01, 0x15, 0x11, 0x05,
0xA1, 0xF0, 0xF8, 0x01, 0x80, 0x81, 0x91, 0x81, 0xA8, 0x0E, 0xB9, 0x1E,
0xB1, 0x82, 0xA0, 0x82, 0x85, 0xE0, 0xF8, 0x2E, 0x8F, 0x2D, 0xDF, 0x91,
0xCF, 0x91, 0x1F, 0x91, 0x0F, 0x91, 0xFF, 0x90, 0xDF, 0x90, 0xCF, 0x90,
0xBF, 0x90, 0xAF, 0x90, 0x08, 0x95, 0x5D, 0xD1, 0x88, 0x23, 0xD1, 0xF2,
0xF8, 0x2E, 0xF0, 0xCF, 0xF6, 0x01, 0x81, 0x91, 0x6F, 0x01, 0x80, 0x93,
0xF1, 0x00, 0x21, 0x97, 0xFF, 0xEF, 0xAF, 0x1A, 0xBF, 0x0A, 0xCE, 0xCF,
0xAF, 0x92, 0xBF, 0x92, 0xCF, 0x92, 0xDF, 0x92, 0xFF, 0x92, 0x0F, 0x93,
0x1F, 0x93, 0xCF, 0x93, 0xDF, 0x93, 0x6C, 0x01, 0xEB, 0x01, 0x8A, 0x01,
0x42, 0xD1, 0xF8, 0x2E, 0x81, 0x11, 0x24, 0xC0, 0x01, 0x15, 0x11, 0x05,
0x39, 0xF0, 0xF8, 0x01, 0x80, 0x81, 0x91, 0x81, 0xC8, 0x1B, 0xD9, 0x0B,
0xC8, 0x0E, 0xD9, 0x1E, 0xB1, 0x2C, 0xA1, 0x2C, 0x20, 0x97, 0xB1, 0xF0,
0x80, 0x91, 0xE8, 0x00, 0x85, 0xFD, 0x22, 0xC0, 0x80, 0x91, 0xE8, 0x00,
0x8B, 0x77, 0x80, 0x93, 0xE8, 0x00, 0x5E, 0xD3, 0x01, 0x15, 0x11, 0x05,
0xA1, 0xF0, 0xF8, 0x01, 0x80, 0x81, 0x91, 0x81, 0xA8, 0x0E, 0xB9, 0x1E,
0xB1, 0x82, 0xA0, 0x82, 0x85, 0xE0, 0xF8, 0x2E, 0x8F, 0x2D, 0xDF, 0x91,
0xCF, 0x91, 0x1F, 0x91, 0x0F, 0x91, 0xFF, 0x90, 0xDF, 0x90, 0xCF, 0x90,
0xBF, 0x90, 0xAF, 0x90, 0x08, 0x95, 0x0F, 0xD1, 0x88, 0x23, 0xD1, 0xF2,
0xF8, 0x2E, 0xF0, 0xCF, 0x80, 0x91, 0xF1, 0x00, 0xF6, 0x01, 0x81, 0x93,
0x6F, 0x01, 0x21, 0x97, 0xFF, 0xEF, 0xAF, 0x1A, 0xBF, 0x0A, 0xCE, 0xCF,
0xFC, 0x01, 0x80, 0x91, 0x83, 0x02, 0x90, 0x91, 0x84, 0x02, 0x86, 0x17,
0x97, 0x07, 0xA0, 0xF0, 0x61, 0x15, 0x71, 0x05, 0x29, 0xF4, 0x90, 0x91,
0xE8, 0x00, 0x9E, 0x77, 0x90, 0x93, 0xE8, 0x00, 0x90, 0xE0, 0x61, 0x15,
0x71, 0x05, 0x51, 0xF4, 0x91, 0x11, 0x08, 0xC0, 0x80, 0x91, 0xE8, 0x00,
0x82, 0xFF, 0x33, 0xC0, 0x80, 0xE0, 0x08, 0x95, 0xBC, 0x01, 0xF2, 0xCF,
0x8E, 0xB3, 0x88, 0x23, 0xB9, 0xF1, 0x85, 0x30, 0xB9, 0xF1, 0x80, 0x91,
0xE8, 0x00, 0x83, 0xFD, 0x2F, 0xC0, 0x80, 0x91, 0xE8, 0x00, 0x82, 0xFD,
0xEB, 0xCF, 0x80, 0x91, 0xE8, 0x00, 0x80, 0xFF, 0xE2, 0xCF, 0x80, 0x91,
0xF3, 0x00, 0x20, 0x91, 0xF2, 0x00, 0x38, 0x2F, 0x61, 0x15, 0x71, 0x05,
0x19, 0xF0, 0x20, 0x34, 0x31, 0x05, 0x58, 0xF0, 0x91, 0xE0, 0x20, 0x34,
0x31, 0x05, 0x09, 0xF0, 0x90, 0xE0, 0x20, 0x91, 0xE8, 0x00, 0x2E, 0x77,
0x20, 0x93, 0xE8, 0x00, 0xCC, 0xCF, 0x81, 0x91, 0x80, 0x93, 0xF1, 0x00,
0x61, 0x50, 0x71, 0x09, 0x2F, 0x5F, 0x3F, 0x4F, 0xE7, 0xCF, 0x8E, 0xB3,
0x88, 0x23, 0x41, 0xF0, 0x85, 0x30, 0x41, 0xF0, 0x80, 0x91, 0xE8, 0x00,
0x83, 0xFF, 0xC0, 0xCF, 0x81, 0xE0, 0x08, 0x95, 0x82, 0xE0, 0x08, 0x95,
0x83, 0xE0, 0x08, 0x95, 0xFC, 0x01, 0x61, 0x15, 0x71, 0x05, 0x29, 0xF4,
0x90, 0x91, 0xE8, 0x00, 0x9B, 0x77, 0x90, 0x93, 0xE8, 0x00, 0x61, 0x15,
0x71, 0x05, 0x31, 0xF4, 0x80, 0x91, 0xE8, 0x00, 0x80, 0xFF, 0x1D, 0xC0,
0x80, 0xE0, 0x08, 0x95, 0x8E, 0xB3, 0x88, 0x23, 0x09, 0xF1, 0x85, 0x30,
0xD9, 0xF0, 0x80, 0x91, 0xE8, 0x00, 0x83, 0xFD, 0x19, 0xC0, 0x80, 0x91,
0xE8, 0x00, 0x82, 0xFF, 0xEA, 0xCF, 0x80, 0x91, 0xF3, 0x00, 0x20, 0x91,
0xF2, 0x00, 0x38, 0x2F, 0x23, 0x2B, 0xF1, 0xF2, 0x80, 0x91, 0xF1, 0x00,
0x81, 0x93, 0x61, 0x50, 0x71, 0x09, 0x99, 0xF7, 0xD7, 0xCF, 0x8E, 0xB3,
0x88, 0x23, 0x31, 0xF0, 0x85, 0x30, 0xD1, 0xF6, 0x83, 0xE0, 0x08, 0x95,
0x81, 0xE0, 0x08, 0x95, 0x82, 0xE0, 0x08, 0x95, 0x8F, 0x70, 0x80, 0x93,
0xE9, 0x00, 0xEB, 0xEE, 0xF0, 0xE0, 0x80, 0x81, 0x81, 0x60, 0x80, 0x83,
0xED, 0xEE, 0xF0, 0xE0, 0x10, 0x82, 0x60, 0x93, 0xEC, 0x00, 0x40, 0x83,
0x80, 0x91, 0xEE, 0x00, 0x88, 0x1F, 0x88, 0x27, 0x88, 0x1F, 0x08, 0x95,
0x0F, 0x93, 0x1F, 0x93, 0xCF, 0x93, 0xDF, 0x93, 0x06, 0x2F, 0xEC, 0x01,
0x10, 0xE0, 0x10, 0x13, 0x02, 0xC0, 0x81, 0xE0, 0x0B, 0xC0, 0x98, 0x81,
0x91, 0x11, 0x03, 0xC0, 0x1F, 0x5F, 0x25, 0x96, 0xF6, 0xCF, 0x89, 0x2F,
0x8F, 0x70, 0x87, 0x30, 0x30, 0xF0, 0x80, 0xE0, 0xDF, 0x91, 0xCF, 0x91,
0x1F, 0x91, 0x0F, 0x91, 0x08, 0x95, 0x2C, 0x81, 0x42, 0xE0, 0x22, 0x30,
0x08, 0xF0, 0x46, 0xE0, 0xE9, 0x81, 0xFA, 0x81, 0x68, 0xE0, 0x70, 0xE0,
0x20, 0xE0, 0x6E, 0x17, 0x7F, 0x07, 0x80, 0xF0, 0x22, 0x95, 0x20, 0x7F,
0x42, 0x2B, 0x6B, 0x81, 0x20, 0xE4, 0x62, 0x9F, 0xB0, 0x01, 0x11, 0x24,
0x99, 0x1F, 0x99, 0x27, 0x99, 0x1F, 0x69, 0x2B, 0xB7, 0xDF, 0x81, 0x11,
0xD7, 0xCF, 0xDD, 0xCF, 0x2F, 0x5F, 0x66, 0x0F, 0x77, 0x1F, 0xE9, 0xCF,
0x80, 0x91, 0x7D, 0x02, 0x87, 0xFF, 0x11, 0xC0, 0x80, 0x91, 0xE8, 0x00,
0x82, 0xFF, 0x06, 0xC0, 0x80, 0x91, 0xE8, 0x00, 0x8B, 0x77, 0x80, 0x93,
0xE8, 0x00, 0x03, 0xC0, 0x8E, 0xB3, 0x81, 0x11, 0xF3, 0xCF, 0x08, 0x95,
0x8E, 0xB3, 0x88, 0x23, 0xE1, 0xF3, 0x80, 0x91, 0xE8, 0x00, 0x80, 0xFF,
0xF9, 0xCF, 0x80, 0x91, 0xE8, 0x00, 0x8E, 0x77, 0xEE, 0xCF, 0x20, 0x91,
0xE4, 0x00, 0x30, 0x91, 0xE5, 0x00, 0x85, 0xE6, 0xA9, 0x01, 0x90, 0x91,
0xEC, 0x00, 0x90, 0xFF, 0x06, 0xC0, 0x90, 0x91, 0xE8, 0x00, 0x90, 0xFF,
0x06, 0xC0, 0x80, 0xE0, 0x08, 0x95, 0x90, 0x91, 0xE8, 0x00, 0x92, 0xFD,
0xFA, 0xCF, 0x9E, 0xB3, 0x99, 0x23, 0x89, 0xF0, 0x95, 0x30, 0x89, 0xF0,
0x90, 0x91, 0xEB, 0x00, 0x95, 0xFD, 0x0F, 0xC0, 0x20, 0x91, 0xE4, 0x00,
0x30, 0x91, 0xE5, 0x00, 0x42, 0x17, 0x53, 0x07, 0x11, 0xF3, 0x81, 0x50,
0xF9, 0xF6, 0x84, 0xE0, 0x08, 0x95, 0x82, 0xE0, 0x08, 0x95, 0x83, 0xE0,
0x08, 0x95, 0x81, 0xE0, 0x08, 0x95, 0x0F, 0x93, 0x1F, 0x93, 0xCF, 0x93,
0xDF, 0x93, 0x46, 0xD0, 0x4D, 0xD0, 0xC8, 0xED, 0xD0, 0xE0, 0x88, 0x81,
0x8F, 0x77, 0x88, 0x83, 0x88, 0x81, 0x80, 0x68, 0x88, 0x83, 0x88, 0x81,
0x8F, 0x7D, 0x88, 0x83, 0x19, 0xBC, 0x1E, 0xBA, 0x10, 0x92, 0x7B, 0x02,
0x00, 0xEE, 0x10, 0xE0, 0xF8, 0x01, 0x80, 0x81, 0x8B, 0x7F, 0x80, 0x83,
0x88, 0x81, 0x81, 0x60, 0x88, 0x83, 0x42, 0xE3, 0x60, 0xE0, 0x80, 0xE0,
0x43, 0xDF, 0xE1, 0xEE, 0xF0, 0xE0, 0x80, 0x81, 0x8E, 0x7F, 0x80, 0x83,
0xE2, 0xEE, 0xF0, 0xE0, 0x80, 0x81, 0x81, 0x60, 0x80, 0x83, 0x80, 0x81,
0x88, 0x60, 0x80, 0x83, 0xF8, 0x01, 0x80, 0x81, 0x8E, 0x7F, 0x80, 0x83,
0x88, 0x81, 0x80, 0x61, 0x88, 0x83, 0xDF, 0x91, 0xCF, 0x91, 0x1F, 0x91,
0x0F, 0x91, 0x08, 0x95, 0xE8, 0xED, 0xF0, 0xE0, 0x80, 0x81, 0x8F, 0x7E,
0x80, 0x83, 0xE7, 0xED, 0xF0, 0xE0, 0x80, 0x81, 0x81, 0x60, 0x80, 0x83,
0x84, 0xE0, 0x82, 0xBF, 0x81, 0xE0, 0x80, 0x93, 0x7C, 0x02, 0xB5, 0xCF,
0xE8, 0xED, 0xF0, 0xE0, 0x80, 0x81, 0x8E, 0x7F, 0x80, 0x83, 0x10, 0x92,
0xE2, 0x00, 0x08, 0x95, 0x10, 0x92, 0xDA, 0x00, 0x10, 0x92, 0xE1, 0x00,
0x08, 0x95, 0x1F, 0x92, 0x0F, 0x92, 0x0F, 0xB6, 0x0F, 0x92, 0x11, 0x24,
0x2F, 0x93, 0x3F, 0x93, 0x4F, 0x93, 0x5F, 0x93, 0x6F, 0x93, 0x7F, 0x93,
0x8F, 0x93, 0x9F, 0x93, 0xAF, 0x93, 0xBF, 0x93, 0xEF, 0x93, 0xFF, 0x93,
0x80, 0x91, 0xDA, 0x00, 0x80, 0xFF, 0x16, 0xC0, 0x80, 0x91, 0xD8, 0x00,
0x80, 0xFF, 0x12, 0xC0, 0x80, 0x91, 0xDA, 0x00, 0x8E, 0x7F, 0x80, 0x93,
0xDA, 0x00, 0x80, 0x91, 0xD9, 0x00, 0x19, 0xBC, 0x80, 0xFF, 0x83, 0xC0,
0x82, 0xE0, 0x89, 0xBD, 0x09, 0xB4, 0x00, 0xFE, 0xFD, 0xCF, 0x81, 0xE0,
0x8E, 0xBB, 0x85, 0xD1, 0x80, 0x91, 0xE1, 0x00, 0x80, 0xFF, 0x17, 0xC0,
0x80, 0x91, 0xE2, 0x00, 0x80, 0xFF, 0x13, 0xC0, 0x80, 0x91, 0xE2, 0x00,
0x8E, 0x7F, 0x80, 0x93, 0xE2, 0x00, 0x80, 0x91, 0xE2, 0x00, 0x80, 0x61,
0x80, 0x93, 0xE2, 0x00, 0x80, 0x91, 0xD8, 0x00, 0x80, 0x62, 0x80, 0x93,
0xD8, 0x00, 0x19, 0xBC, 0x85, 0xE0, 0x8E, 0xBB, 0x6A, 0xD1, 0x80, 0x91,
0xE1, 0x00, 0x84, 0xFF, 0x26, 0xC0, 0x80, 0x91, 0xE2, 0x00, 0x84, 0xFF,
0x22, 0xC0, 0x19, 0xBC, 0x82, 0xE0, 0x89, 0xBD, 0x09, 0xB4, 0x00, 0xFE,
0xFD, 0xCF, 0x80, 0x91, 0xD8, 0x00, 0x8F, 0x7D, 0x80, 0x93, 0xD8, 0x00,
0x80, 0x91, 0xE1, 0x00, 0x8F, 0x7E, 0x80, 0x93, 0xE1, 0x00, 0x80, 0x91,
0xE2, 0x00, 0x8F, 0x7E, 0x80, 0x93, 0xE2, 0x00, 0x80, 0x91, 0xE2, 0x00,
0x81, 0x60, 0x80, 0x93, 0xE2, 0x00, 0x80, 0x91, 0x7B, 0x02, 0x88, 0x23,
0x09, 0xF4, 0x3C, 0xC0, 0x84, 0xE0, 0x8E, 0xBB, 0x40, 0xD1, 0x80, 0x91,
0xE1, 0x00, 0x83, 0xFF, 0x21, 0xC0, 0x80, 0x91, 0xE2, 0x00, 0x83, 0xFF,
0x1D, 0xC0, 0x80, 0x91, 0xE1, 0x00, 0x87, 0x7F, 0x80, 0x93, 0xE1, 0x00,
0x82, 0xE0, 0x8E, 0xBB, 0x10, 0x92, 0x7B, 0x02, 0x80, 0x91, 0xE1, 0x00,
0x8E, 0x7F, 0x80, 0x93, 0xE1, 0x00, 0x80, 0x91, 0xE2, 0x00, 0x8E, 0x7F,
0x80, 0x93, 0xE2, 0x00, 0x80, 0x91, 0xE2, 0x00, 0x80, 0x61, 0x80, 0x93,
0xE2, 0x00, 0x42, 0xE3, 0x60, 0xE0, 0x80, 0xE0, 0x79, 0xDE, 0x1B, 0xD1,
0xFF, 0x91, 0xEF, 0x91, 0xBF, 0x91, 0xAF, 0x91, 0x9F, 0x91, 0x8F, 0x91,
0x7F, 0x91, 0x6F, 0x91, 0x5F, 0x91, 0x4F, 0x91, 0x3F, 0x91, 0x2F, 0x91,
0x0F, 0x90, 0x0F, 0xBE, 0x0F, 0x90, 0x1F, 0x90, 0x18, 0x95, 0x1E, 0xBA,
0x08, 0xD1, 0x82, 0xCF, 0x80, 0x91, 0xE3, 0x00, 0x87, 0xFD, 0x02, 0xC0,
0x81, 0xE0, 0xBF, 0xCF, 0x83, 0xE0, 0xBD, 0xCF, 0x1F, 0x93, 0xCF, 0x93,
0xDF, 0x93, 0x00, 0xD0, 0xCD, 0xB7, 0xDE, 0xB7, 0x8D, 0xE7, 0x92, 0xE0,
0x20, 0x91, 0xF1, 0x00, 0xFC, 0x01, 0x21, 0x93, 0xCF, 0x01, 0xF2, 0xE0,
0x85, 0x38, 0x9F, 0x07, 0xB9, 0xF7, 0xB3, 0xDC, 0x80, 0x91, 0xE8, 0x00,
0x83, 0xFF, 0x11, 0xC0, 0x90, 0x91, 0x7D, 0x02, 0x80, 0x91, 0x7E, 0x02,
0x85, 0x30, 0x09, 0xF4, 0x99, 0xC0, 0xE8, 0xF4, 0x81, 0x30, 0x09, 0xF4,
0x60, 0xC0, 0x88, 0x23, 0x09, 0xF4, 0x3D, 0xC0, 0x83, 0x30, 0x09, 0xF4,
0x5A, 0xC0, 0x80, 0x91, 0xE8, 0x00, 0x83, 0xFF, 0x0A, 0xC0, 0x80, 0x91,
0xE8, 0x00, 0x87, 0x7F, 0x80, 0x93, 0xE8, 0x00, 0x80, 0x91, 0xEB, 0x00,
0x80, 0x62, 0x80, 0x93, 0xEB, 0x00, 0x0F, 0x90, 0x0F, 0x90, 0xDF, 0x91,
0xCF, 0x91, 0x1F, 0x91, 0x08, 0x95, 0x88, 0x30, 0x09, 0xF4, 0x97, 0xC0,
0x89, 0x30, 0x09, 0xF4, 0xA1, 0xC0, 0x86, 0x30, 0x21, 0xF7, 0x90, 0x58,
0x92, 0x30, 0x08, 0xF7, 0xAE, 0x01, 0x4F, 0x5F, 0x5F, 0x4F, 0x60, 0x91,
0x81, 0x02, 0x80, 0x91, 0x7F, 0x02, 0x90, 0x91, 0x80, 0x02, 0xB5, 0xDC,
0xBC, 0x01, 0x89, 0x2B, 0xA1, 0xF2, 0x90, 0x91, 0xE8, 0x00, 0x97, 0x7F,
0x90, 0x93, 0xE8, 0x00, 0x89, 0x81, 0x9A, 0x81, 0x6D, 0xDD, 0x80, 0x91,
0xE8, 0x00, 0x8B, 0x77, 0x80, 0x93, 0xE8, 0x00, 0xC6, 0xCF, 0x90, 0x38,
0xE1, 0xF0, 0x92, 0x38, 0x09, 0xF0, 0xC1, 0xCF, 0x80, 0x91, 0x81, 0x02,
0x8F, 0x70, 0x80, 0x93, 0xE9, 0x00, 0x80, 0x91, 0xEB, 0x00, 0x85, 0xFB,
0x88, 0x27, 0x80, 0xF9, 0x10, 0x92, 0xE9, 0x00, 0x90, 0x91, 0xE8, 0x00,
0x97, 0x7F, 0x90, 0x93, 0xE8, 0x00, 0x80, 0x93, 0xF1, 0x00, 0x10, 0x92,
0xF1, 0x00, 0x80, 0x91, 0xE8, 0x00, 0x8E, 0x77, 0x20, 0xC0, 0x80, 0xE0,
0xF1, 0xCF, 0x92, 0x30, 0x09, 0xF0, 0xA3, 0xCF, 0x90, 0x91, 0x7F, 0x02,
0x91, 0x11, 0x12, 0xC0, 0x90, 0x91, 0x81, 0x02, 0x9F, 0x70, 0x09, 0xF4,
0x9A, 0xCF, 0x90, 0x93, 0xE9, 0x00, 0x20, 0x91, 0xEB, 0x00, 0x20, 0xFF,
0x07, 0xC0, 0x83, 0x30, 0x71, 0xF4, 0x80, 0x91, 0xEB, 0x00, 0x80, 0x62,
0x80, 0x93, 0xEB, 0x00, 0x10, 0x92, 0xE9, 0x00, 0x80, 0x91, 0xE8, 0x00,
0x87, 0x7F, 0x80, 0x93, 0xE8, 0x00, 0x0A, 0xDE, 0x84, 0xCF, 0x80, 0x91,
0xEB, 0x00, 0x80, 0x61, 0x80, 0x93, 0xEB, 0x00, 0x21, 0xE0, 0x30, 0xE0,
0x01, 0xC0, 0x22, 0x0F, 0x9A, 0x95, 0xEA, 0xF7, 0x20, 0x93, 0xEA, 0x00,
0x10, 0x92, 0xEA, 0x00, 0x80, 0x91, 0xEB, 0x00, 0x88, 0x60, 0xE2, 0xCF,
0x91, 0x11, 0x6F, 0xCF, 0x10, 0x91, 0x7F, 0x02, 0x1F, 0x77, 0x80, 0x91,
0xE3, 0x00, 0x80, 0x78, 0x81, 0x2B, 0x80, 0x93, 0xE3, 0x00, 0x80, 0x91,
0xE8, 0x00, 0x87, 0x7F, 0x80, 0x93, 0xE8, 0x00, 0xE5, 0xDD, 0x80, 0x91,
0xE8, 0x00, 0x80, 0xFF, 0xFC, 0xCF, 0x80, 0x91, 0xE3, 0x00, 0x80, 0x68,
0x80, 0x93, 0xE3, 0x00, 0x82, 0xE0, 0x11, 0x11, 0x83, 0xE0, 0x8E, 0xBB,
0x52, 0xCF, 0x90, 0x38, 0x09, 0xF0, 0x4F, 0xCF, 0x80, 0x91, 0xE8, 0x00,
0x87, 0x7F, 0x80, 0x93, 0xE8, 0x00, 0x80, 0x91, 0x7B, 0x02, 0x80, 0x93,
0xF1, 0x00, 0x99, 0xCF, 0x91, 0x11, 0x43, 0xCF, 0x90, 0x91, 0x7F, 0x02,
0x92, 0x30, 0x08, 0xF0, 0x3E, 0xCF, 0x80, 0x91, 0xE8, 0x00, 0x87, 0x7F,
0x80, 0x93, 0xE8, 0x00, 0x90, 0x93, 0x7B, 0x02, 0xBB, 0xDD, 0x80, 0x91,
0x7B, 0x02, 0x88, 0x23, 0x11, 0xF0, 0x84, 0xE0, 0x05, 0xC0, 0x80, 0x91,
0xE3, 0x00, 0x87, 0xFD, 0xFA, 0xCF, 0x81, 0xE0, 0x8E, 0xBB, 0xB8, 0xDB,
0x28, 0xCF, 0x08, 0x95, 0xCF, 0x93, 0x8E, 0xB3, 0x88, 0x23, 0x91, 0xF0,
0xC0, 0x91, 0xE9, 0x00, 0xCF, 0x70, 0x80, 0x91, 0xEC, 0x00, 0x80, 0xFD,
0x0D, 0xC0, 0x80, 0xE0, 0xC8, 0x2B, 0x10, 0x92, 0xE9, 0x00, 0x80, 0x91,
0xE8, 0x00, 0x83, 0xFD, 0xED, 0xDE, 0xCF, 0x70, 0xC0, 0x93, 0xE9, 0x00,
0xCF, 0x91, 0x08, 0x95, 0x80, 0xE8, 0xF2, 0xCF, 0xCF, 0x93, 0xDF, 0x93,
0xEC, 0x01, 0x1B, 0x86, 0x82, 0xE0, 0x8C, 0x83, 0x89, 0x87, 0x61, 0xE0,
0xCE, 0x01, 0x01, 0x96, 0x4B, 0xDD, 0x88, 0x23, 0x31, 0xF0, 0x61, 0xE0,
0xCE, 0x01, 0x06, 0x96, 0xDF, 0x91, 0xCF, 0x91, 0x43, 0xCD, 0x80, 0xE0,
0xDF, 0x91, 0xCF, 0x91, 0x08, 0x95, 0x9B, 0x01, 0x4E, 0xB3, 0x44, 0x30,
0xB9, 0xF4, 0xFC, 0x01, 0x91, 0x81, 0x9F, 0x70, 0x90, 0x93, 0xE9, 0x00,
0x50, 0xE0, 0x40, 0xE0, 0x64, 0xE0, 0x70, 0xE0, 0xC9, 0x01, 0xEC, 0xDB,
0x81, 0x11, 0x0B, 0xC0, 0x90, 0x91, 0xE8, 0x00, 0x95, 0xFD, 0x07, 0xC0,
0x90, 0x91, 0xE8, 0x00, 0x9E, 0x77, 0x90, 0x93, 0xE8, 0x00, 0x08, 0x95,
0x82, 0xE0, 0x08, 0x95, 0x2E, 0xB3, 0x24, 0x30, 0x89, 0xF4, 0xFC, 0x01,
0x81, 0x81, 0x8F, 0x70, 0x80, 0x93, 0xE9, 0x00, 0x90, 0x91, 0xF3, 0x00,
0x80, 0x91, 0xF2, 0x00, 0x89, 0x2B, 0x41, 0xF0, 0x80, 0x91, 0xE8, 0x00,
0x8E, 0x77, 0x80, 0x93, 0xE8, 0x00, 0x67, 0xCD, 0x82, 0xE0, 0x08, 0x95,
0x80, 0xE0, 0x08, 0x95, 0xFC, 0x01, 0x8E, 0xB3, 0x84, 0x30, 0x51, 0xF4,
0x91, 0x81, 0x9F, 0x70, 0x90, 0x93, 0xE9, 0x00, 0x80, 0x91, 0xE8, 0x00,
0x80, 0xFF, 0x02, 0xC0, 0xCF, 0x01, 0xDA, 0xCF, 0x08, 0x95, 0x9B, 0x01,
0x4E, 0xB3, 0x44, 0x30, 0x11, 0xF0, 0x80, 0xE0, 0x08, 0x95, 0xFC, 0x01,
0x96, 0x81, 0x9F, 0x70, 0x90, 0x93, 0xE9, 0x00, 0x80, 0x91, 0xE8, 0x00,
0x82, 0xFF, 0xF5, 0xCF, 0x80, 0x91, 0xE8, 0x00, 0x85, 0xFF, 0xF1, 0xCF,
0x50, 0xE0, 0x40, 0xE0, 0x64, 0xE0, 0x70, 0xE0, 0xC9, 0x01, 0xEC, 0xDB,
0x80, 0x91, 0xE8, 0x00, 0x85, 0xFD, 0x05, 0xC0, 0x80, 0x91, 0xE8, 0x00,
0x8B, 0x77, 0x80, 0x93, 0xE8, 0x00, 0x81, 0xE0, 0x08, 0x95, 0xF9, 0x99,
0xFE, 0xCF, 0x92, 0xBD, 0x81, 0xBD, 0xF8, 0x9A, 0x99, 0x27, 0x80, 0xB5,
0x08, 0x95, 0xF8, 0x94, 0xFF, 0xCF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x08, 0x03, 0x86, 0x40, 0x00, 0x00, 0x01, 0x05, 0x40, 0x00, 0x00,
0x01, 0x00, 0x12, 0x03, 0x51, 0x00, 0x75, 0x00, 0x69, 0x00, 0x72, 0x00,
0x6B, 0x00, 0x62, 0x00, 0x6F, 0x00, 0x74, 0x00, 0x00, 0x00, 0x04, 0x03,
0x09, 0x04, 0x09, 0x02, 0xAA, 0x00, 0x04, 0x01, 0x00, 0x60, 0x32, 0x08,
0x0B, 0x00, 0x02, 0x02, 0x02, 0x01, 0x00, 0x09, 0x04, 0x00, 0x00, 0x01,
0x02, 0x02, 0x01, 0x00, 0x05, 0x24, 0x00, 0x10, 0x01, 0x04, 0x24, 0x02,
0x06, 0x05, 0x24, 0x06, 0x00, 0x01, 0x07, 0x05, 0x82, 0x03, 0x08, 0x00,
0xFF, 0x09, 0x04, 0x01, 0x00, 0x02, 0x0A, 0x00, 0x00, 0x00, 0x07, 0x05,
0x04, 0x02, 0x10, 0x00, 0x05, 0x07, 0x05, 0x83, 0x02, 0x10, 0x00, 0x05,
0x08, 0x0B, 0x02, 0x02, 0x01, 0x01, 0x00, 0x00, 0x09, 0x04, 0x02, 0x00,
0x00, 0x01, 0x01, 0x00, 0x00, 0x09, 0x24, 0x01, 0x00, 0x01, 0x09, 0x00,
0x01, 0x03, 0x09, 0x04, 0x03, 0x00, 0x02, 0x01, 0x03, 0x00, 0x00, 0x07,
0x24, 0x01, 0x00, 0x01, 0x41, 0x00, 0x06, 0x24, 0x02, 0x01, 0x01, 0x00,
0x06, 0x24, 0x02, 0x02, 0x02, 0x00, 0x09, 0x24, 0x03, 0x01, 0x03, 0x01,
0x02, 0x01, 0x00, 0x09, 0x24, 0x03, 0x02, 0x04, 0x01, 0x01, 0x01, 0x00,
0x09, 0x05, 0x05, 0x02, 0x40, 0x00, 0x00, 0x00, 0x00, 0x05, 0x25, 0x01,
0x01, 0x01, 0x09, 0x05, 0x86, 0x02, 0x40, 0x00, 0x00, 0x00, 0x00, 0x05,
0x25, 0x01, 0x01, 0x03, 0x12, 0x01, 0x00, 0x02, 0xEF, 0x02, 0x01, 0x40,
0x86, 0x28, 0x06, 0xF0, 0x00, 0x01, 0x01, 0x02, 0x00, 0x01, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x70, 0x00, 0x00,
0x31, 0x30, 0x42, 0x51,
};
unsigned long bootloader_data_termination = 0x00007000;
unsigned long bootloader_data_start       = 0x00007000;
unsigned long bootloader_data_finish      = 0x00008000;
unsigned long bootloader_data_length      = 0x00001000;

#define BOOTLOADER_DATA_TERMINATION 0x00007000
#define BOOTLOADER_DATA_START       0x00007000
#define BOOTLOADER_DATA_FINISH      0x00008000
#define BOOTLOADER_DATA_LENGTH      0x00001000
// The ideas used in this code are based off bootjacker:
// http://oneweekwonder.blogspot.com.au/2014/07/bootjacker-amazing-avr-bootloader-hack.html

#include <stdint.h>
#include <stdbool.h>

#include <avr/io.h>
#include <avr/boot.h>
#include <avr/pgmspace.h>
#include <avr/interrupt.h>
#include <avr/wdt.h>
#include <util/atomic.h>
#include <util/delay.h>

#define kSpmCsr (_SFR_IO_ADDR(SPMCSR))
#define kSpmCsrMem (kSpmCsr+0x20)

#define IOAddrInsMask(aPort) (((aPort&0x30)<<5)|(aPort&7))

// We prefer to write our custom SPM instruction in the last page of the
// bootloader. If we can't write to that block (because the SPM instruction
// itself is inside it, then write to the first block).
#define IDEAL_BLOCK_ADDR (FLASHEND - SPM_PAGESIZE + 1)

#define kStsIns 0x9200
#define kStsRegMask 0x01f0
#define kOutSpmCsrIns (0xb800 + IOAddrInsMask(kSpmCsr))
#define kOutSpmCsrRegMask 0x01f0
#define kSpmIns 0x95e8

#define kFlashPageSize (1<<kFlashPageSizeBits)
#define kFlashPageSizeInWords (1<<(kFlashPageSizeBits-1))
#define kFlashSpmEnMask (1<<0)
#define kFlashSpmEraseMask (1<<1)
#define kFlashSpmWritePageMask (1<<2)
#define kFlashSpmBlbSetMask (1<<3)
#define kFlashSpmRwwsReMask (1<<4)
#define kFlashSpmRwwsBusyMask (1<<6)

#define kFlashSpmEn kFlashSpmEnMask
#define kFlashSpmErase (kFlashSpmEraseMask|kFlashSpmEnMask)
#define kFlashSpmWritePage (kFlashSpmWritePageMask|kFlashSpmEnMask)
#define kFlashSpmBlbSet (kFlashSpmBlbSetMask|kFlashSpmEnMask)
#define kFlashSpmRwws (kFlashSpmRwwsReMask|kFlashSpmEnMask)
#define kFlashSpmRwwsBusy (kFlashSpmRwwsBusyMask)

// Debug LEDs
#define LED0_DDR DDRB
#define LED0_PORT PORTB
#define LED0_BIT _BV(0)

#define LED1_DDR DDRD
#define LED1_PORT PORTD
#define LED1_BIT _BV(5)

#define LED0_SETUP (LED0_DDR |= LED0_BIT)
#define LED1_SETUP (LED1_DDR |= LED1_BIT)

#define LED0_OFF (LED0_PORT &= ~LED0_BIT)
#define LED1_OFF (LED1_PORT &= ~LED1_BIT)

#define LED0_ON (LED0_PORT |= LED0_BIT)
#define LED1_ON (LED1_PORT |= LED1_BIT)

#define LED0_TOGGLE (LED0_PORT ^= LED0_BIT)
#define LED1_TOGGLE (LED1_PORT ^= LED1_BIT)

// NOTE: Uses even numbers for ideal configurations, odd numbers for suboptimal
typedef enum {
    SPM_TYPE_STS_IDEAL = 0,
    SPM_TYPE_STS_SECONDARY = 1,
    SPM_TYPE_OUT_IDEAL = 2,
    SPM_TYPE_OUT_SECONARY = 3,
    SPM_TYPE_NONE = 7
} spm_type;

uint16_t gSpmSequenceAddr;
uint16_t boot_start;
uint16_t boot_end;

const uint8_t gBootloaderJmpVector[] = {
    0x57, 0xbf, 0xe8, 0x95, // An out, spm command.
    0x00, 0x00,             // nop
    0xFF, 0xCF,             // rjmp -1 (infinite loop)
};



uint8_t find_spm(void) {
    uint8_t spmType = SPM_TYPE_NONE;
    uint16_t addr;

    for( addr=boot_start; addr < boot_end; addr+=2) {
        if ((spmType & 1) == 0) {
            break;
        }

        const uint16_t word_0 = pgm_read_word(addr+0);
        const uint16_t word_1 = pgm_read_word(addr+2);
        const uint16_t word_2 = pgm_read_word(addr+4);

        if (
            (word_0 & ~kStsRegMask) == kStsIns &&
            word_1 == kSpmCsrMem &&
            word_2 == kSpmIns
        ) {
            if (addr+8 < IDEAL_BLOCK_ADDR) {
                spmType = SPM_TYPE_STS_IDEAL;
                gSpmSequenceAddr = addr;
                break;
            } else {
                spmType = SPM_TYPE_STS_SECONDARY;
            }
        }


        // kSpmCsr (_SFR_IO_ADDR(SPMCSR))
        // kSpmCsrMem (kSpmCsr+0x20)
        // IOAddrInsMask(aPort) (((aPort&0x30)<<5)|(aPort&7))
        // kOutSpmCsrIns (0xb800 + IOAddrInsMask(kSpmCsr))
        // kOutSpmCsrRegMask 0x01f0
        // kSpmIns 0x95e8
        //
        // OUT A, Rr:
        // 16-bit Opcode
        // 1011 1AAr rrrr AAAA
        // AA.....AAAA ->
        // ..rrrrr.... ->
        //
        // A  = SPMCSR
        // Rr = register (r20 atmel DFU)

        // out SPMCSR, R20; argument 2 decides function (r18)
        // SPM                ;Store program memory
        if (
            (word_0 & ~kOutSpmCsrRegMask) == kOutSpmCsrIns &&
            word_1 == kSpmIns
        ) {
            if (addr+6 < IDEAL_BLOCK_ADDR) {
                spmType = SPM_TYPE_OUT_IDEAL;
                gSpmSequenceAddr = addr;
                break;
            } else {
                spmType = SPM_TYPE_OUT_SECONARY;
            }
        }

        // Save the SPM address
        if (spmType != SPM_TYPE_NONE) {
            gSpmSequenceAddr = addr;
        }
    }

    return spmType;
}

#define BLB1_MASK 0x30 // controls access of bootloader section
#define BLB0_MASK 0x0C // controls access of application section
#define BLB_MASK 0x03 // controls access from external progarmmer

// Check lock bits. We need to be able to do the following things:
// 1. Use the SPM instruction to write to the bootloader.
// 2. From the application section, be allowed to read the bootloader code.
// 3. When executing from the bootloader, allow interrupt code stored in the
//    application section to execute
//
// This means we need full access to the bootloader (i.e. both bits
// a BLB1 need to be unprogrammed).
uint8_t check_bootloader_lock_bits(void) {
    // uint8_t lfuse;
    // uint8_t hfuse;
    // uint8_t efuse;
    uint8_t lock_bits;

    ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
        // TODO: check other fuse bits
        // lfuse = boot_lock_fuse_bits_get(GET_LOW_FUSE_BITS);
        // hfuse = boot_lock_fuse_bits_get(GET_HIGH_FUSE_BITS);
        // efuse = boot_lock_fuse_bits_get(GET_EXTENDED_FUSE_BITS);
        lock_bits = boot_lock_fuse_bits_get(GET_LOCK_BITS);
    }

    if( (lock_bits & BLB1_MASK) != BLB1_MASK) {
        return -1;
    }

    return 0;
}

void setup_timer0(uint8_t cycles) {

#if defined (__AVR_ATmega32U4__)
    TCCR0B = 0;       // stop the timer.
    TCCR0A = 0;       // mode 0, no OCR outputs.
    TCNT0 = 0;        // reset the timer
    TIFR0 = (1<<OCF0B) | (1<<OCF0A) | (1<<TOV0); // clear all pending timer0 interrupts.
    OCR0B = cycles; // number of cycles to wait
    TIMSK0 = (1<<OCIE0B); // OCR0B interrupt enabled.
#elif defined (__AVR_ATmega168__)
    // Note: Pretty sure Fignition which bootjacker was made for uses ATmega168
    TCCR0B = 0;       // stop the timer.
    TCCR0A = 0;       // mode 0, no OCR outputs.
    TCNT0 = 0;        // reset the timer
    TIFR0 = (1<<OCF0B) | (1<<OCF0A) | (1<<TOV0);  // clear all pending timer0 interrupts.
    OCR0B = cycles;   // 40 clocks from now (40 in test, 31 for real).
    TIMSK0 = (1<<OCIE0B);     // OCR0B interrupt enabled.
#else
#error "Current microcontroller is unsupported or untested."
#endif

}

// Found this value by experimentation.
// This value should be chosen so the timer0 interrupt will be called on the
// instruction immediately following the SPM instruction.
#define SPM_LEAP_CYCLES_USING_STS 40
#define SPM_LEAP_CYCLES_USING_OUT 39

// This function will call the SPM instruction we found in the bootloader
// while setting `R0:R1` <- `optValue` and `Z` <- `addr`.
//
// Note:  I'm not sure if this function will work correctly if it tries to
// modify a value in the application space.
// If the SPM instruction targets the bootloader section, then the CPU will
// be halted while she SPM operation is executed, however if the SPM instruction
// targets the application space, then code will continue executing in the
// bootloader. However the application code cannot be read while the SPM
// operation is executing, therefore it is necessary for the code to wait for
// the SPM instruction to finish executing before returning to the application
// space.
//
// We only want to update code in the bootloader, should not be an issue, but
// if we did want to do this, we would need to write our own SPM instruction
// into the bootloader space which includes a loop to wait for the SPM
// instruction to finish.
void spm_leap_cmd(uint16_t addr, uint8_t spmCmd, uint16_t optValue) {
    uint8_t cmdReg, tmp=0;

    const uint8_t spmaddr_zl = (gSpmSequenceAddr >> 0) & 0xff;
    const uint8_t spmaddr_zh = (gSpmSequenceAddr >> 8) & 0xff;
    // Will probably need this for devices that have more than 128kb flash
    // const uint8_t spmaddr_rz = (gSpmSequenceAddr >> 16) & 0xff;
    const uint8_t spmaddr_rz = 0;

    // Assume that the instruction before SPM is `OUT SPMCSR, rXX`
    // Or it is using STS SPMCSR, rXX.  Need to extract the rXX from
    // the instruction.  It's in the same place for both opcodes:
    //1001 001d dddd 0000
    cmdReg = (uint8_t)(
        (pgm_read_word(gSpmSequenceAddr)>>4) & 0x1f
    );

    PINC|=(1<<4);
    asm volatile(
        "push r0\n"
        "push r1\n"             // needed for opt command.
        "push %[tmp]\n"
        "push r30\n"
        "push r31\n"

        //wait for spm operation complete.
        "SpmLeapCmdWaitSpm: in %[tmp], %[SPM_CSR]\n" //
        "sbrc %[tmp],0\n"
        "rjmp SpmLeapCmdWaitSpm\n"

        // start the TCCR0B timer
        "ldi %[tmp],1\n"     // timer 0 start at fClk
        "out %[_TCCR0B],%[tmp]\n"    // set TCCR0B so off we go. This is time 0c.

        // To call the smp instruction, we first need to write to the SPMCSR
        // register. The variable cmdReg holds the register that will be
        // written to the SPMCSR. We save the current value of cmdReg now
        // and push it to the stack to restore later
        "movw r0, %[optValue] \n"   // set the value to be written. (1c)
        "mov r30, %[cmdReg] \n"   // get the register used by the sequence's spm command. (1c)
        "ldi r31, 0\n"    // z^reg to save. (1c)
        "ld %[tmp], Z\n"      // get the reg (2c)
        "push %[tmp]\n"      // saved it, now we can overwrite with spm command. (2c)
        "push %[cmdReg]\n" // save cmdReg

        // Push the address that will be returned to from the spm instruction.
        "ldi r30,lo8(pm(SpmLeapCmdRet))\n" // (1c)
        "ldi r31,hi8(pm(SpmLeapCmdRet))\n" // (1c)
        "push r30\n"     // (2c)
        "push r31\n"     // return address must be pushed big-endian. (2c)

        //
        "mov r30, %[spmaddr_l]\n" // lo byte of Spm sequence address (1c)
        "mov r31, %[spmaddr_h]\n" // hi byte of Spm sequence address. z^sequence in code. (1c)
        // Convert the gSpmSequenceAddr from a byte address to a word address
        "lsr r31\n"      // (1c)
        "ror r30\n"      // div 2 to get correct Spm program address. (1c)

        "push r30\n"     // (2c)
        "push r31\n"     // Spm sequence program address must be pushed big-endian. (2c)

        "push %A[addr]\n"     // before we overwrite reg used by sequence's spm command
                              // we must first save the spm target address (2c)
        "push %B[addr]\n"     // in case it would get overwritten by the st Z. (2c)

        // store the spm command into the cmdReg
        "mov r30, %[cmdReg]\n"   // get the register used by the sequence's spm command. (1c)
        "ldi r31, 0\n"    // z^reg to save. (1c)
        "st Z, %[spmCmd] \n"      // store the command in the reg. (2c)

        "pop r31\n"      // (2c)
        "pop r30\n"      // restore the spm target address into Z. // (2c)

        // the gSpmSequenceAddr is now on the top of the stack, return here
        // to enter the bootloader
        "ret\n"          // return to bootloader. (4c(16bit PC)) (5c (22bit PC))

        // sts (2c)   // alternatively OUT (1c)
        // spm (1c). 42c in total, timer should be set to 40.

        // Return from the bootloader, pop values from stack and return
        "SpmLeapCmdRet:\n"
        "pop %[cmdReg]\n"             // restore command Reg address
        "pop %[tmp]\n"                // restore command Reg value
        "mov r30, %[cmdReg]\n"
        "ldi r31,0\n"   // z^reg to save.
        "st Z,%[tmp]\n"     // pop the reg
        "pop r31\n"
        "pop r30\n"
        "pop %[tmp]\n"
        "pop r1\n"
        "pop r0\n"
            // output registers
            : "=d" (tmp),                                   // %0
              "=r" (addr)                                   // %1
            // input registers
            : [_TCCR0B] "I" (_SFR_IO_ADDR(TCCR0B)),         // %2
              [cmdReg] "r" (cmdReg),                        // %3
              [spmCmd] "r" (spmCmd),                        // %4
              [optValue] "r" (optValue),                    // %5
              [addr] "0" (addr),                            // %6
              [spmaddr_l] "r" (spmaddr_zl),                 // %7
              [spmaddr_h] "r" (spmaddr_zh),                 // %8
              [spmaddr_z] "r" (spmaddr_rz),                 // %9
              [SPM_CSR] "I" (kSpmCsr),                      // %10
              [tmp] "d" (tmp)                               // %11
    );

}

/**
 * The timer interrupt interrupted bootloader execution
 * just after the spm instruction.
 * if we ret then we'll get back to the bootloader.
 * we need to pop the return address and then ret, which
 * should take us back to the SpmLeapCommand.
 **/
// TODO: need to set this interrupt vector to the one that matches the
// timer we will add later.
ISR(TIMER0_COMPB_vect, ISR_NAKED) { // OCR0B
    asm volatile(
        "ldi r30,0\n"
        "out %[_TCCR0B],r30\n"  // stop timer 0
        "out %[_TCNT0],r30\n"  // reset timer 0.
        "ldi r30,7\n"
        "out %[_TIFR0],r30\n"  // clear interrupts on timer 0.
        "pop r31\n"     // don't care about overwiting Z because SpmLeap doesn't need it.
        "pop r30\n"
        "reti\n"
            :
            : [_TCCR0B] "I" (_SFR_IO_ADDR(TCCR0B)),
            [_TCNT0] "I" (_SFR_IO_ADDR(TCNT0)),
            [_TIFR0] "I" (_SFR_IO_ADDR(TIFR0))
    );
}


// Write the data in src to the address at
void flash_write_page(const uint8_t *src, uint16_t dst, uint8_t length) {
    // Fill the temporary buffer for the page write
    for(uint16_t addr=0; addr < length; addr+=2) {        // 64 words.
        uint16_t data = *((uint16_t*)src);
        spm_leap_cmd(dst+addr, kFlashSpmEn, data);
        src+=2; // advance to next word
    }

    // Erase and write the target page
    spm_leap_cmd(dst, kFlashSpmErase, 0);
    spm_leap_cmd(dst, kFlashSpmWritePage, 0);
}

void show_success(void) {
    cli();
    LED0_ON;
    while (1) {
    }
}

void enter_bootloader(void){
  cli();
  // Set the bootloader key to the magic value and force a reset
  *(uint16_t *)0x0800 = 0x7777;
  wdt_enable(WDTO_15MS);
  for (;;);
}

void bootloader_upgrade(void) {
    uint16_t our_spm_page;

    boot_start = (FLASHEND - bootloader_data_length)+1;
    boot_end = boot_start + bootloader_data_length;

    // Check if the bootloader has already been programmed
    {
        uint8_t is_match = 1;
        for (uint16_t i = 0; i < bootloader_data_length; ++i) {
            if (pgm_read_byte(bootloader_data+i) != pgm_read_byte(boot_start + i) ) {
                is_match = 0;
                break;
            }
        }

        if (is_match) {
            for (uint16_t i = 0; i < 5; ++i) {
                LED0_ON;
                LED1_ON;
                _delay_ms(50);
                LED0_OFF;
                LED1_OFF;
                _delay_ms(50);
            }
            enter_bootloader();
        }
    }


    // Check the bootloader lock bits, if incompatible lock bits are found
    // then don't run the bootloader upgrade procedure, and go back to bootloader mode
    if (check_bootloader_lock_bits()) {
        for (uint16_t i = 0; i < 5; ++i) {
            LED0_ON;
            LED1_OFF;
            _delay_ms(50);
            LED0_OFF;
            LED1_ON;
            _delay_ms(50);
        }
        LED1_OFF;
        enter_bootloader();
    }

    // Find the SPM instruction and what the surrounding instructions are.
    uint8_t spmType = find_spm();

    // Need to try and disable any interrupt source that the bootloader my have
    // setup (really the bootloader shouldn't change these from their default
    // values).
#ifdef __AVR_ATmega32U4__

    // Disable all other interrupt sources
  TIMSK0 = 0; // Disable timer 0 interrupts
  TIFR0 = 0x07;
  TIMSK1 = 0; // Disable timer 1 interrupts
  TIFR1 = 0x17;
  EIMSK = 0;  // Disable external interrupts
  EIFR = 0x03;
  PCICR = 0;  // all Pin Change interrupts off (Tape uses them).
  PCIFR = 0x01; // pending pin change interrupts cleared.

    USBCON = 0;
    USBINT = (1<<VBUSTI);

    UDIEN = 0;
    UDINT = 0xff;
#else
#error "Unsupported/tested microcontroller"
#endif

    sei(); // Need interrupts enabled

    if (spmType == SPM_TYPE_STS_SECONDARY || spmType == SPM_TYPE_STS_IDEAL) {
        setup_timer0(SPM_LEAP_CYCLES_USING_STS);   // sts timing.
    } else if (spmType == SPM_TYPE_OUT_SECONARY || spmType == SPM_TYPE_OUT_IDEAL) {
        setup_timer0(SPM_LEAP_CYCLES_USING_OUT); // out timing is one cycle less.
    }

    // if (spmType == SPM_TYPE_STS_SECONDARY || spmType == SPM_TYPE_OUT_SECONARY) {
    //     our_spm_page = BOOTLOADER_START;
    // } else {
    //     our_spm_page = BOOTLOADER_END - SPM_PAGE;
    // }
    our_spm_page = IDEAL_BLOCK_ADDR;

    flash_write_page(
        gBootloaderJmpVector,
        our_spm_page,
        sizeof(gBootloaderJmpVector)
    );

    // We write a custom block with an SPM instruction as the last page of flash.
    // It uses an out instruction, so setup the timer appropriately.
    setup_timer0(SPM_LEAP_CYCLES_USING_OUT);
    gSpmSequenceAddr = our_spm_page;

    flash_write_page(
        gBootloaderJmpVector,
        0x7000,
        sizeof(gBootloaderJmpVector)
    );

    // We can now overwrite the bootloader with our replacement bootloader.
    {
        uint16_t boot_pos = 0;

        while (
            boot_pos < bootloader_data_length &&
            (boot_pos < (bootloader_data_length-SPM_PAGESIZE))
        ) {
            uint8_t page_data[SPM_PAGESIZE];

            for (uint16_t i = 0; i < SPM_PAGESIZE; ++i) {
                page_data[i] = pgm_read_byte(bootloader_data+(boot_pos + i));
            }

            // The data is now loaded into ram, write the page
            flash_write_page(
                page_data,
                boot_start + boot_pos,
                SPM_PAGESIZE
            );
            boot_pos += SPM_PAGESIZE;

        }

        // To write the page at `BOOTLOADER_END-SPM_PAGESIZE` we can not use the
        // SPM instruction in the final page (i.e. the currently executing page).
        // So what we want to do is find another SPM instruction that we wrote
        // inside the bootloader elsewhere (obviously if there isn't any this
        // won't work).
        // TODO: check the bootloader_data meets this requirement before
        // attempting to write the bootloader.
        {
            // Find the SPM instruction and what the surrounding instructions are.
            uint8_t spmType = find_spm();

            // Set the timer for the new instruction sequence
            if (spmType == SPM_TYPE_STS_SECONDARY || spmType == SPM_TYPE_STS_IDEAL) {
                setup_timer0(SPM_LEAP_CYCLES_USING_STS);   // sts timing.
            } else {
                setup_timer0(SPM_LEAP_CYCLES_USING_OUT); // out timing is one cycle less.
            }

            // load the final page from flash
            uint8_t page_data[SPM_PAGESIZE];
            for (uint16_t i = 0; i < SPM_PAGESIZE; ++i) {
                page_data[i] = pgm_read_byte(bootloader_data+(bootloader_data_length-SPM_PAGESIZE + i));
            }

            flash_write_page(
                page_data,
                boot_end - SPM_PAGESIZE,
                SPM_PAGESIZE
            );
        }
    }
}

#define CPU_PRESCALE(n) (CLKPR = 0x80, CLKPR = (n))

int main(void) {
    // Clear the pre-scaler in case it was set by fuses
    CPU_PRESCALE(0); // set for 16 MHz clock

    // Disable watch dog if it is active
    wdt_disable();

    LED0_SETUP;
    LED1_SETUP;

    LED0_OFF;
    LED1_OFF;

    // We want to make sure that interrupts are executed from the application
    // section not the bootloader. In case the bootloader set IVSEL to 1, we
    // clear it here.
    {
        // NOTE: JTD, PUD are also cleared here but we don't care
        MCUCR = (1<<IVCE); // Enable change of interrupt vectors
        MCUCR = (0<<IVCE) | (0<<IVSEL); // Clear IVSEL, i.e. interrupts from app section
    }

    _delay_ms(100);

    bootloader_upgrade();

    // If we finish go into the bootloafer
    enter_bootloader();
}
